#!/usr/bin/env node

/**
 * Feature Generator Script v·ªõi Form Standardization
 * 
 * @description T·ª± ƒë·ªông t·∫°o folder structure v√† files cho feature m·ªõi
 * @usage node scripts/create-feature.js <feature-name> <area>
 * @example node scripts/create-feature.js products admin
 */

const fs = require('fs');
const path = require('path');

// Utility functions
const toPascalCase = (str) => str.charAt(0).toUpperCase() + str.slice(1).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
const toCamelCase = (str) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());

// Template generators
const generateIndexTemplate = (featureName) => {
  const featureCamel = toCamelCase(featureName);
  return `// ‚úÖ Pages
export { ${featureName}ListPage, ${featureName}DetailPage, ${featureName}CreatePage } from './pages';

// ‚úÖ Components
export { ${featureName}Table, ${featureName}Form, ${featureName}Card } from './components';

// ‚úÖ Hooks
export { use${featureName}s, use${featureName}, useCreate${featureName}, useUpdate${featureName}, useDelete${featureName} } from './hooks';

// ‚úÖ Services
export { ${featureCamel}Api } from './services';

// ‚úÖ Types
export type { ${featureName}, ${featureName}FormData, ${featureName}Filters, ${featureName}Params } from './types';

// ‚úÖ Router
export { default as ${featureName}Router } from './router';
`;
};

const generateRouterTemplate = (featureName, featureCamel) => {
  return `import React from 'react';
import { Routes, Route } from 'react-router-dom';
import { ErrorBoundary, ErrorFallback } from 'shared/components';
import { ProtectedRoute } from 'shared/guards';
import { 
  ${featureName}ListPage, 
  ${featureName}DetailPage, 
  ${featureName}CreatePage,
  ${featureName}EditPage 
} from './pages';

/**
 * ${featureName} Feature Router
 * 
 * @description Routes cho ${featureCamel} feature v·ªõi ErrorBoundary
 * @author Generated by script
 */
export default function ${featureName}Router() {
  return (
    <ErrorBoundary fallback={ErrorFallback}>
      <Routes>
        {/* Danh s√°ch ${featureCamel} */}
        <Route path="/" element={<${featureName}ListPage />} />
        
        {/* T·∫°o m·ªõi ${featureCamel} */}
        <Route 
          path="/create" 
          element={
            <ProtectedRoute requirePermission="${featureCamel}:create">
              <${featureName}CreatePage />
            </ProtectedRoute>
          } 
        />
        
        {/* Chi ti·∫øt ${featureCamel} */}
        <Route path="/:id" element={<${featureName}DetailPage />} />
        
        {/* Ch·ªânh s·ª≠a ${featureCamel} */}
        <Route 
          path="/:id/edit" 
          element={
            <ProtectedRoute requirePermission="${featureCamel}:update">
              <${featureName}EditPage />
            </ProtectedRoute>
          } 
        />
      </Routes>
    </ErrorBoundary>
  );
}
`;
};

const generateFormTemplate = (featureName, featureCamel) => {
  return `import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from 'shared/components/ui/form';
import { Button } from 'shared/components/ui/button';
import { Input } from 'shared/components/ui/input';
import { Textarea } from 'shared/components/ui/textarea';
import { Alert, AlertDescription } from 'shared/components/ui/alert';
import { AlertTriangle } from 'lucide-react';
import { useCreate${featureName}, useUpdate${featureName} } from '../hooks';
import type { ${featureName}FormData } from '../types';

// ‚úÖ Validation schema v·ªõi Zod
const ${featureCamel}Schema = z.object({
  name: z.string().min(1, 'T√™n l√† b·∫Øt bu·ªôc').max(255, 'T√™n kh√¥ng ƒë∆∞·ª£c qu√° 255 k√Ω t·ª±'),
  description: z.string().optional(),
  // Th√™m c√°c field kh√°c theo y√™u c·∫ßu
});

interface ${featureName}FormProps {
  onSubmit?: (data: ${featureName}FormData) => void;
  onCancel?: () => void;
  defaultValues?: Partial<${featureName}FormData>;
  isEdit?: boolean;
  ${featureCamel}Id?: string;
}

/**
 * ${featureName} Form Component v·ªõi standardized patterns
 * 
 * @description Form ƒë·ªÉ t·∫°o/ch·ªânh s·ª≠a ${featureCamel} v·ªõi React Hook Form + Zod validation
 * @author Generated by script
 */
export function ${featureName}Form({ 
  onSubmit, 
  onCancel,
  defaultValues, 
  isEdit = false,
  ${featureCamel}Id
}: ${featureName}FormProps) {
  const form = useForm<${featureName}FormData>({
    resolver: zodResolver(${featureCamel}Schema),
    defaultValues: defaultValues || {
      name: '',
      description: ''
    }
  });

  const createMutation = useCreate${featureName}();
  const updateMutation = useUpdate${featureName}();
  const [submitError, setSubmitError] = useState<string | null>(null);

  const handleSubmit = async (data: ${featureName}FormData) => {
    try {
      setSubmitError(null);
      
      if (isEdit && ${featureCamel}Id) {
        await updateMutation.mutateAsync({ id: ${featureCamel}Id, data });
      } else {
        await createMutation.mutateAsync(data);
      }
      
      onSubmit?.(data);
    } catch (error) {
      setSubmitError(error instanceof Error ? error.message : 'C√≥ l·ªói x·∫£y ra');
    }
  };

  const isLoading = createMutation.isPending || updateMutation.isPending;

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
        {/* Error Alert */}
        {submitError && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>{submitError}</AlertDescription>
          </Alert>
        )}

        {/* Name Field */}
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>T√™n ${featureName} *</FormLabel>
              <FormControl>
                <Input 
                  placeholder="Nh·∫≠p t√™n ${featureCamel}" 
                  {...field} 
                  disabled={isLoading}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Description Field */}
        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>M√¥ t·∫£</FormLabel>
              <FormControl>
                <Textarea 
                  placeholder="Nh·∫≠p m√¥ t·∫£ ${featureCamel}" 
                  rows={3}
                  {...field} 
                  disabled={isLoading}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Action Buttons */}
        <div className="flex gap-4 pt-4">
          <Button 
            type="submit" 
            disabled={isLoading}
            className="flex-1"
          >
            {isLoading 
              ? 'ƒêang l∆∞u...' 
              : isEdit ? 'C·∫≠p nh·∫≠t' : 'T·∫°o m·ªõi'
            }
          </Button>
          
          {onCancel && (
            <Button 
              type="button" 
              variant="outline" 
              onClick={onCancel}
              disabled={isLoading}
              className="flex-1"
            >
              H·ªßy
            </Button>
          )}
        </div>
      </form>
    </Form>
  );
}

export default ${featureName}Form;
`;
};

const generateTypesTemplate = (featureName, featureCamel) => {
  return `/**
 * ${featureName} Types
 * 
 * @description TypeScript interfaces cho ${featureCamel} feature
 * @author Generated by script
 */

/**
 * ${featureName} Entity
 */
export interface ${featureName} {
  id: string;
  name: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
  // Th√™m c√°c field kh√°c theo y√™u c·∫ßu
}

/**
 * ${featureName} Form Data
 */
export interface ${featureName}FormData {
  name: string;
  description?: string;
  // Th√™m c√°c field kh√°c theo y√™u c·∫ßu
}

/**
 * ${featureName} Filters
 */
export interface ${featureName}Filters {
  search?: string;
  status?: string;
  // Th√™m c√°c filter kh√°c theo y√™u c·∫ßu
}

/**
 * ${featureName} Query Params
 */
export interface ${featureName}Params extends ${featureName}Filters {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * ${featureName} Store State (Zustand)
 */
export interface ${featureName}Store {
  selectedItems: string[];
  filters: ${featureName}Filters;
  setSelectedItems: (items: string[]) => void;
  setFilters: (filters: ${featureName}Filters) => void;
  clearFilters: () => void;
}
`;
};

const generateApiServiceTemplate = (featureName, featureCamel) => {
  return `import { api } from 'shared/core/lib/api';
import type { 
  ${featureName}, 
  ${featureName}FormData, 
  ${featureName}Params 
} from '../types';

/**
 * ${featureName} API Service
 * 
 * @description X·ª≠ l√Ω t·∫•t c·∫£ API calls li√™n quan ƒë·∫øn ${featureCamel}
 * @author Generated by script
 */
export const ${featureCamel}Api = {
  /**
   * L·∫•y danh s√°ch ${featureCamel}
   */
  getAll: async (params?: ${featureName}Params): Promise<${featureName}[]> => {
    const response = await api.get('/${featureCamel}s', { params });
    return response.data;
  },
  
  /**
   * L·∫•y ${featureCamel} theo ID
   */
  getById: async (id: string): Promise<${featureName}> => {
    const response = await api.get(\`/${featureCamel}s/\${id}\`);
    return response.data;
  },
  
  /**
   * T·∫°o m·ªõi ${featureCamel}
   */
  create: async (data: ${featureName}FormData): Promise<${featureName}> => {
    const response = await api.post('/${featureCamel}s', data);
    return response.data;
  },
  
  /**
   * C·∫≠p nh·∫≠t ${featureCamel}
   */
  update: async (id: string, data: Partial<${featureName}FormData>): Promise<${featureName}> => {
    const response = await api.put(\`/${featureCamel}s/\${id}\`, data);
    return response.data;
  },
  
  /**
   * X√≥a ${featureCamel}
   */
  delete: async (id: string): Promise<void> => {
    await api.delete(\`/${featureCamel}s/\${id}\`);
  }
};
`;
};

const generateHooksTemplate = (featureName, featureCamel) => {
  return `import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'shared/hooks/use-toast';
import { ${featureCamel}Api } from '../services';
import type { 
  ${featureName}, 
  ${featureName}FormData, 
  ${featureName}Params 
} from '../types';

/**
 * ${featureName} React Query Hooks
 * 
 * @description Standardized hooks cho ${featureCamel} feature v·ªõi comprehensive error handling
 * @author Generated by script
 */

/**
 * Hook l·∫•y danh s√°ch ${featureCamel}
 */
export const use${featureName}s = (params?: ${featureName}Params) => {
  return useQuery({
    queryKey: ['${featureCamel}s', params],
    queryFn: () => ${featureCamel}Api.getAll(params),
    throwOnError: true, // Let ErrorBoundary catch
    retry: (failureCount, error) => {
      // Don't retry on 4xx errors
      if (error.response?.status >= 400 && error.response?.status < 500) {
        return false;
      }
      return failureCount < 3;
    },
    meta: { errorMessage: 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch ${featureCamel}' }
  });
};

/**
 * Hook l·∫•y ${featureCamel} theo ID
 */
export const use${featureName} = (id: string) => {
  return useQuery({
    queryKey: ['${featureCamel}', id],
    queryFn: () => ${featureCamel}Api.getById(id),
    enabled: !!id,
    throwOnError: true,
    meta: { errorMessage: 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin ${featureCamel}' }
  });
};

/**
 * Hook t·∫°o m·ªõi ${featureCamel}
 */
export const useCreate${featureName} = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ${featureCamel}Api.create,
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['${featureCamel}s'] });
      toast.success('T·∫°o ${featureCamel} th√†nh c√¥ng!');
    },
    onError: (error) => {
      toast.error(error.message || 'C√≥ l·ªói x·∫£y ra khi t·∫°o ${featureCamel}');
    },
    throwOnError: false // Handle locally in forms
  });
};

/**
 * Hook c·∫≠p nh·∫≠t ${featureCamel}
 */
export const useUpdate${featureName} = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<${featureName}FormData> }) =>
      ${featureCamel}Api.update(id, data),
    onSuccess: (data) => {
      queryClient.setQueryData(['${featureCamel}', data.id], data);
      queryClient.invalidateQueries({ queryKey: ['${featureCamel}s'] });
      toast.success('C·∫≠p nh·∫≠t ${featureCamel} th√†nh c√¥ng!');
    },
    onError: (error) => {
      toast.error(error.message || 'C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t ${featureCamel}');
    },
    throwOnError: false
  });
};

/**
 * Hook x√≥a ${featureCamel}
 */
export const useDelete${featureName} = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ${featureCamel}Api.delete,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['${featureCamel}s'] });
      toast.success('X√≥a ${featureCamel} th√†nh c√¥ng!');
    },
    onError: (error) => {
      toast.error(error.message || 'C√≥ l·ªói x·∫£y ra khi x√≥a ${featureCamel}');
    },
    throwOnError: false
  });
};
`;
};

const generatePageTemplate = (featureName, featureCamel, pageName) => {
  return `import React from 'react';
import { ErrorBoundary, LoadingSpinner } from 'shared/components';
import { use${featureName}s } from '../hooks';

interface ${featureName}${pageName}PageProps {
  // Define props if needed
}

/**
 * ${featureName} ${pageName} Page Component
 * 
 * @description Trang ${pageName.toLowerCase()} ${featureCamel} v·ªõi ErrorBoundary
 * @author Generated by script
 */
export default function ${featureName}${pageName}Page(props: ${featureName}${pageName}PageProps) {
  // ‚úÖ Hooks
  const { data, isLoading, error } = use${featureName}s();
  
  // ‚úÖ Early returns
  if (isLoading) return <LoadingSpinner text="ƒêang t·∫£i ${featureCamel}..." />;
  if (error) throw error; // Let ErrorBoundary catch

  return (
    <ErrorBoundary>
      <div className="container mx-auto py-6">
        <h1 className="text-2xl font-bold mb-6">${featureName} ${pageName}</h1>
        
        {/* Content */}
        <div className="space-y-6">
          {/* Add your content here */}
          <p className="text-muted-foreground">
            ${pageName} page for ${featureCamel} feature - implement your UI here
          </p>
        </div>
      </div>
    </ErrorBoundary>
  );
}
`;
};

// Main function
function createFeature(featureName, area = 'admin') {
  if (!featureName) {
    console.error('‚ùå Feature name is required!');
    console.log('Usage: node scripts/create-feature.js <feature-name> <area>');
    console.log('Example: node scripts/create-feature.js products admin');
    process.exit(1);
  }

  const featurePascal = toPascalCase(featureName);
  const featureCamel = toCamelCase(featureName);
  const featureKebab = featureName.toLowerCase();

  const basePath = path.join(__dirname, '..', 'src', area, 'features', featureKebab);

  console.log('üöÄ Creating feature: ' + featurePascal + ' in ' + area);
  console.log('üìÅ Path: ' + basePath);

  // Create directories
  const dirs = [
    basePath,
    path.join(basePath, 'pages'),
    path.join(basePath, 'components'),
    path.join(basePath, 'hooks'),
    path.join(basePath, 'services'),
    path.join(basePath, 'types'),
    path.join(basePath, 'utils')
  ];

  dirs.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log('‚úÖ Created directory: ' + dir);
    }
  });

  // Create files
  const files = [
    {
      path: path.join(basePath, 'index.ts'),
      content: generateIndexTemplate(featurePascal)
    },
    {
      path: path.join(basePath, 'router.tsx'),
      content: generateRouterTemplate(featurePascal, featureCamel)
    },
    {
      path: path.join(basePath, 'types', 'index.ts'),
      content: generateTypesTemplate(featurePascal, featureCamel)
    },
    {
      path: path.join(basePath, 'services', 'index.ts'),
      content: generateApiServiceTemplate(featurePascal, featureCamel)
    },
    {
      path: path.join(basePath, 'hooks', 'index.ts'),
      content: generateHooksTemplate(featurePascal, featureCamel)
    },
    {
      path: path.join(basePath, 'components', featurePascal + 'Form.tsx'),
      content: generateFormTemplate(featurePascal, featureCamel)
    },
    {
      path: path.join(basePath, 'pages', featurePascal + 'ListPage.tsx'),
      content: generatePageTemplate(featurePascal, featureCamel, 'List')
    },
    {
      path: path.join(basePath, 'pages', featurePascal + 'DetailPage.tsx'),
      content: generatePageTemplate(featurePascal, featureCamel, 'Detail')
    },
    {
      path: path.join(basePath, 'pages', featurePascal + 'CreatePage.tsx'),
      content: generatePageTemplate(featurePascal, featureCamel, 'Create')
    },
    {
      path: path.join(basePath, 'pages', 'index.ts'),
      content: 'export { default as ' + featurePascal + 'ListPage } from \'./' + featurePascal + 'ListPage\';\n' +
               'export { default as ' + featurePascal + 'DetailPage } from \'./' + featurePascal + 'DetailPage\';\n' +
               'export { default as ' + featurePascal + 'CreatePage } from \'./' + featurePascal + 'CreatePage\';\n' +
               'export { default as ' + featurePascal + 'EditPage } from \'./' + featurePascal + 'CreatePage\'; // Reuse create page for now\n'
    },
    {
      path: path.join(basePath, 'components', 'index.ts'),
      content: '// Export components here\n' +
               'export { default as ' + featurePascal + 'Form } from \'./' + featurePascal + 'Form\';\n' +
               '// export { ' + featurePascal + 'Table } from \'./' + featurePascal + 'Table\';\n' +
               '// export { ' + featurePascal + 'Card } from \'./' + featurePascal + 'Card\';\n'
    }
  ];

  files.forEach(file => {
    if (!fs.existsSync(file.path)) {
      fs.writeFileSync(file.path, file.content);
      console.log('‚úÖ Created file: ' + file.path);
    } else {
      console.log('‚ö†Ô∏è  File already exists: ' + file.path);
    }
  });

  console.log('\nüéâ Feature ' + featurePascal + ' created successfully!');
  console.log('\nüìù Next steps:');
  console.log('1. Add feature router to ' + area + ' routes');
  console.log('2. Implement page components');
  console.log('3. Create table and card components');
  console.log('4. Adjust API endpoints and types');
  console.log('5. Test form validation and error handling');
}

// Run script
const [,, featureName, area] = process.argv;
createFeature(featureName, area || 'admin');